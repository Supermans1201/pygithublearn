From 5544ffc0c164951004ff1bc3da4ca59588badc28 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C3=80lex=20Magaz=20Gra=C3=A7a?= <rivaldi8@gmail.com>
Date: Mon, 16 Nov 2015 10:24:32 +0100
Subject: [PATCH] Fix: sharing exported files via external service not working

Exporter now generates a list of exported files on internal storage which can then be directed to any destination
Splitting of QIF files (per currency) now occurs during the export process itself

Fixes #423
Closes #425
---
 .../gnucash/android/export/ExportAsyncTask.java    | 201 +++++++++------------
 .../org/gnucash/android/export/ExportParams.java   |   5 +-
 .../java/org/gnucash/android/export/Exporter.java  |  69 ++-----
 .../gnucash/android/export/ofx/OfxExporter.java    |  47 +++--
 .../gnucash/android/export/qif/QifExporter.java    |  50 ++---
 .../gnucash/android/export/xml/GncXmlExporter.java |  71 ++++++--
 6 files changed, 216 insertions(+), 227 deletions(-)

diff --git a/app/src/main/java/org/gnucash/android/export/ExportAsyncTask.java b/app/src/main/java/org/gnucash/android/export/ExportAsyncTask.java
index 6709a9af..97c219bf 100644
--- a/app/src/main/java/org/gnucash/android/export/ExportAsyncTask.java
+++ b/app/src/main/java/org/gnucash/android/export/ExportAsyncTask.java
@@ -28,6 +28,7 @@
 import android.os.AsyncTask;
 import android.os.Build;
 import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import android.widget.Toast;
 
@@ -59,13 +60,11 @@
 import org.gnucash.android.ui.settings.SettingsActivity;
 import org.gnucash.android.ui.transaction.TransactionsActivity;
 
-import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.OutputStreamWriter;
 import java.nio.channels.FileChannel;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
@@ -96,6 +95,11 @@
      */
     private ExportParams mExportParams;
 
+    // File paths generated by the exporter
+    private List<String> mExportedFiles;
+
+    private Exporter mExporter;
+
     public ExportAsyncTask(Context context){
         this.mContext = context;
     }
@@ -126,7 +130,6 @@ protected void onPreExecute() {
     protected Boolean doInBackground(ExportParams... params) {
         mExportParams = params[0];
 
-        Exporter mExporter;
         switch (mExportParams.getExportFormat()) {
                 case QIF:
                     mExporter = new QifExporter(mExportParams);
@@ -140,20 +143,11 @@ protected Boolean doInBackground(ExportParams... params) {
                 default:
                     mExporter = new GncXmlExporter(mExportParams);
                     break;
-            }
+        }
 
         try {
-            File file = new File(mExportParams.getInternalExportPath());
-            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"));
-            try {
-                // FIXME: detect if there aren't transactions to export and inform the user
-                mExporter.generateExport(writer);
-                writer.flush();
-            }
-            finally {
-                writer.close();
-            }
-
+            // FIXME: detect if there aren't transactions to export and inform the user
+            mExportedFiles = mExporter.generateExport();
         } catch (final Exception e) {
             Log.e(TAG, "Error exporting: " + e.getMessage());
             Crashlytics.logException(e);
@@ -174,16 +168,16 @@ public void run() {
 
         switch (mExportParams.getExportTarget()) {
             case SHARING:
-                File output = moveExportToSDCard();
-                shareFile(output.getAbsolutePath());
+                List<String> sdCardExportedFiles = moveExportToSDCard();
+                shareFiles(sdCardExportedFiles);
                 return true;
 
             case DROPBOX:
-                copyExportToDropbox();
+                moveExportToDropbox();
                 return true;
 
             case GOOGLE_DRIVE:
-                copyExportToGoogleDrive();
+                moveExportToGoogleDrive();
                 return true;
 
             case SD_CARD:
@@ -250,7 +244,7 @@ protected void onPostExecute(Boolean exportResult) {
         }
     }
 
-    private void copyExportToGoogleDrive(){
+    private void moveExportToGoogleDrive(){
         Log.i(TAG, "Moving exported file to Google Drive");
         final GoogleApiClient googleApiClient = SettingsActivity.getGoogleApiClient(GnuCashApplication.getAppContext());
         googleApiClient.blockingConnect();
@@ -258,11 +252,10 @@ private void copyExportToGoogleDrive(){
                 ResultCallback<DriveFolder.DriveFileResult>() {
                     @Override
                     public void onResult(DriveFolder.DriveFileResult result) {
-                        if (!result.getStatus().isSuccess()) {
+                        if (!result.getStatus().isSuccess())
                             Log.e(TAG, "Error while trying to sync to Google Drive");
-                            return;
-                        }
-                        Log.i(TAG, "Created a file with content: " + result.getDriveFile().getDriveId());
+                        else
+                            Log.i(TAG, "Created a file with content: " + result.getDriveFile().getDriveId());
                     }
                 };
 
@@ -277,12 +270,11 @@ public void onResult(DriveApi.DriveContentsResult result) {
                 try {
                     // write content to DriveContents
                     OutputStream outputStream = driveContents.getOutputStream();
-                    List<String> exportedFilePaths = getExportedFiles();
-                    for (String exportedFilePath : exportedFilePaths) {
+                    for (String exportedFilePath : mExportedFiles) {
                         File exportedFile = new File(exportedFilePath);
                         FileInputStream fileInputStream = new FileInputStream(exportedFile);
                         byte[] buffer = new byte[1024];
-                        int count = 0;
+                        int count;
 
                         while ((count = fileInputStream.read(buffer)) >= 0) {
                             outputStream.write(buffer, 0, count);
@@ -293,7 +285,7 @@ public void onResult(DriveApi.DriveContentsResult result) {
 
                         MetadataChangeSet changeSet = new MetadataChangeSet.Builder()
                                 .setTitle(exportedFile.getName())
-                                .setMimeType(getExportMimeType())
+                                .setMimeType(mExporter.getExportMimeType())
                                 .build();
 
                         SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(mContext);
@@ -312,22 +304,7 @@ public void onResult(DriveApi.DriveContentsResult result) {
         });
     }
 
-    /**
-     * Returns the mime type for the configured export format
-     * @return MIME type as string
-     */
-    public String getExportMimeType(){
-        switch (mExportParams.getExportFormat()){
-            case OFX:
-            case XML:
-                return "text/xml";
-            case QIF:
-            default:
-                return "text/plain";
-        }
-    }
-
-    private void copyExportToDropbox() {
+    private void moveExportToDropbox() {
         Log.i(TAG, "Copying exported file to DropBox");
         String dropboxAppKey = mContext.getString(R.string.dropbox_app_key, SettingsActivity.DROPBOX_APP_KEY);
         String dropboxAppSecret = mContext.getString(R.string.dropbox_app_secret, SettingsActivity.DROPBOX_APP_SECRET);
@@ -336,8 +313,7 @@ private void copyExportToDropbox() {
         DbxFile dbExportFile = null;
         try {
             DbxFileSystem dbxFileSystem = DbxFileSystem.forAccount(mDbxAcctMgr.getLinkedAccount());
-            List<String> exportedFilePaths = getExportedFiles();
-            for (String exportedFilePath : exportedFilePaths) {
+            for (String exportedFilePath : mExportedFiles) {
                 File exportedFile = new File(exportedFilePath);
                 dbExportFile = dbxFileSystem.create(new DbxPath(exportedFile.getName()));
                 dbExportFile.writeFromExistingFile(exportedFile, false);
@@ -357,43 +333,35 @@ private void copyExportToDropbox() {
         }
     }
 
-    /**
-     * Returns the list of files generated by one export session.
-     * <p>Typically it is one file. But QIF export generate multiple files per currency.</p>
-     * @return List of paths to exported files
-     * @throws IOException if the exported files could not be created
-     */
-    private List<String> getExportedFiles() throws IOException {
-        List<String> exportedFilePaths;
-        if (mExportParams.getExportFormat() == ExportFormat.QIF) {
-            String path = mExportParams.getInternalExportPath();
-            exportedFilePaths = QifExporter.splitQIF(new File(path));
-        } else {
-            exportedFilePaths = new ArrayList<>();
-            exportedFilePaths.add(mExportParams.getInternalExportPath());
-        }
-        return exportedFilePaths;
-    }
 
     /**
-     * Moves the exported file from the internal storage where it is generated to external storage
-     * which is accessible to the user.
-     * @return File to which the export was moved.
+     * Moves the exported files from the internal storage where they are generated to
+     * external storage, which is accessible to the user.
+     * @return The list of files moved to the SD card.
      */
-    private File moveExportToSDCard() {
+    private List<String> moveExportToSDCard() {
         Log.i(TAG, "Moving exported file to external storage");
-        File src = new File(mExportParams.getInternalExportPath());
-        File dst = Exporter.createExportFile(mExportParams.getExportFormat());
+        new File(Exporter.EXPORT_FOLDER_PATH).mkdirs();
+        List<String> dstFiles = new ArrayList<>();
 
-        try {
-            copyFile(src, dst);
-            src.delete();
-            return dst;
-        } catch (IOException e) {
-            Crashlytics.logException(e);
-            Log.e(TAG, e.getMessage());
-            throw new Exporter.ExporterException(mExportParams, e);
+        for (String src: mExportedFiles) {
+            String dst = Exporter.EXPORT_FOLDER_PATH + stripPathPart(src);
+            try {
+                moveFile(src, dst);
+                dstFiles.add(dst);
+            } catch (IOException e) {
+                Crashlytics.logException(e);
+                Log.e(TAG, e.getMessage());
+                throw new Exporter.ExporterException(mExportParams, e);
+            }
         }
+
+        return dstFiles;
+    }
+
+    // "/some/path/filename.ext" -> "filename.ext"
+    private String stripPathPart(String fullPathName) {
+        return (new File(fullPathName)).getName();
     }
 
     /**
@@ -418,37 +386,25 @@ private void backupAndDeleteTransactions(){
 
     /**
      * Starts an intent chooser to allow the user to select an activity to receive
-     * the exported OFX file
-     * @param path String path to the file on disk
+     * the exported files.
+     * @param paths list of full paths of the files to send to the activity.
      */
-    private void shareFile(String path) {
-        String defaultEmail = PreferenceManager.getDefaultSharedPreferences(mContext)
-                .getString(mContext.getString(R.string.key_default_export_email), null);
+    private void shareFiles(List<String> paths) {
         Intent shareIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);
         shareIntent.setType("text/xml");
-        ArrayList<Uri> exportFiles = new ArrayList<>();
-        if (mExportParams.getExportFormat() == ExportFormat.QIF) {
-            try {
-                List<String> splitFiles = QifExporter.splitQIF(new File(path));
-                for (String file : splitFiles) {
-                    exportFiles.add(Uri.parse("file://" + file));
-                }
-            } catch (IOException e) {
-                Log.e(TAG, "Error split up files in shareFile. " + e.getMessage());
-                Crashlytics.logException(e);
-                return;
-            }
-        } else {
-            exportFiles.add(Uri.parse("file://" + path));
-        }
+
+        ArrayList<Uri> exportFiles = convertPathsToUris(paths);
         shareIntent.putExtra(Intent.EXTRA_STREAM, exportFiles);
+
         shareIntent.putExtra(Intent.EXTRA_SUBJECT, mContext.getString(R.string.title_export_email,
                 mExportParams.getExportFormat().name()));
-        if (defaultEmail != null && defaultEmail.trim().length() > 0) {
+
+        String defaultEmail = PreferenceManager.getDefaultSharedPreferences(mContext)
+                .getString(mContext.getString(R.string.key_default_export_email), null);
+        if (defaultEmail != null && defaultEmail.trim().length() > 0)
             shareIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{defaultEmail});
-        }
-        SimpleDateFormat formatter = (SimpleDateFormat) SimpleDateFormat.getDateTimeInstance();
 
+        SimpleDateFormat formatter = (SimpleDateFormat) SimpleDateFormat.getDateTimeInstance();
         ArrayList<CharSequence> extraText = new ArrayList<>();
         extraText.add(mContext.getString(R.string.description_export_email)
                 + " " + formatter.format(new Date(System.currentTimeMillis())));
@@ -457,7 +413,8 @@ private void shareFile(String path) {
         if (mContext instanceof Activity) {
             List<ResolveInfo> activities = mContext.getPackageManager().queryIntentActivities(shareIntent, 0);
             if (activities != null && !activities.isEmpty()) {
-                mContext.startActivity(Intent.createChooser(shareIntent, mContext.getString(R.string.title_select_export_destination)));
+                mContext.startActivity(Intent.createChooser(shareIntent,
+                        mContext.getString(R.string.title_select_export_destination)));
             } else {
                 Toast.makeText(mContext, R.string.toast_no_compatible_apps_to_receive_export,
                         Toast.LENGTH_LONG).show();
@@ -465,27 +422,37 @@ private void shareFile(String path) {
         }
     }
 
+    // /some/path/file.ext -> file:///some/path/file.ext
+    @NonNull
+    private ArrayList<Uri> convertPathsToUris(List<String> paths) {
+        ArrayList<Uri> exportFiles = new ArrayList<>();
+
+        for (String file : paths)
+            exportFiles.add(Uri.parse("file://" + file));
+
+        return exportFiles;
+    }
+
     /**
-     * Copies a file from <code>src</code> to <code>dst</code>
+     * Moves a file from <code>src</code> to <code>dst</code>
      * @param src Absolute path to the source file
      * @param dst Absolute path to the destination file
-     * @throws IOException if the file could not be copied
+     * @throws IOException if the file could not be moved.
      */
-    public void copyFile(File src, File dst) throws IOException {
-        //TODO: Make this asynchronous at some time, t in the future
-        if (mExportParams.getExportFormat() == ExportFormat.QIF) {
-            QifExporter.splitQIF(src, dst);
-        } else {
-            FileChannel inChannel = new FileInputStream(src).getChannel();
-            FileChannel outChannel = new FileOutputStream(dst).getChannel();
-            try {
-                inChannel.transferTo(0, inChannel.size(), outChannel);
-            } finally {
-                if (inChannel != null)
-                    inChannel.close();
-                outChannel.close();
-            }
+    public void moveFile(String src, String dst) throws IOException {
+        //TODO: Make this asynchronous at some time, t in the future.
+        File srcFile = new File(src);
+        File dstFile = new File(dst);
+        FileChannel inChannel = new FileInputStream(srcFile).getChannel();
+        FileChannel outChannel = new FileOutputStream(dstFile).getChannel();
+        try {
+            inChannel.transferTo(0, inChannel.size(), outChannel);
+        } finally {
+            if (inChannel != null)
+                inChannel.close();
+            outChannel.close();
         }
+        srcFile.delete();
     }
 
 }
diff --git a/app/src/main/java/org/gnucash/android/export/ExportParams.java b/app/src/main/java/org/gnucash/android/export/ExportParams.java
index 50619cc4..7d859621 100644
--- a/app/src/main/java/org/gnucash/android/export/ExportParams.java
+++ b/app/src/main/java/org/gnucash/android/export/ExportParams.java
@@ -166,11 +166,10 @@ public String toString() {
      */
     public String toCsv(){
         String separator = ";";
-        String csv = mExportFormat.name() + separator + mExportTarget.name() + separator
+
+        return mExportFormat.name() + separator + mExportTarget.name() + separator
                 + mExportStartTime.toString() + separator
                 + Boolean.toString(mDeleteTransactionsAfterExport);
-
-        return csv;
     }
 
     /**
diff --git a/app/src/main/java/org/gnucash/android/export/Exporter.java b/app/src/main/java/org/gnucash/android/export/Exporter.java
index 41f04166..bbbb7b46 100644
--- a/app/src/main/java/org/gnucash/android/export/Exporter.java
+++ b/app/src/main/java/org/gnucash/android/export/Exporter.java
@@ -34,13 +34,11 @@
 import org.gnucash.android.db.SplitsDbAdapter;
 import org.gnucash.android.db.TransactionsDbAdapter;
 
-import java.io.File;
-import java.io.FileFilter;
-import java.io.Writer;
 import java.sql.Timestamp;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -92,7 +90,7 @@
     protected TransactionsDbAdapter mTransactionsDbAdapter;
     protected SplitsDbAdapter mSplitsDbAdapter;
     protected ScheduledActionDbAdapter mScheduledActionDbAdapter;
-    protected PricesDbAdapter mPricesDbAdpater;
+    protected PricesDbAdapter mPricesDbAdapter;
     protected CommoditiesDbAdapter mCommoditiesDbAdapter;
     protected Context mContext;
 
@@ -104,14 +102,14 @@ public Exporter(ExportParams params, SQLiteDatabase db) {
             mTransactionsDbAdapter = TransactionsDbAdapter.getInstance();
             mSplitsDbAdapter = SplitsDbAdapter.getInstance();
             mScheduledActionDbAdapter = ScheduledActionDbAdapter.getInstance();
-            mPricesDbAdpater = PricesDbAdapter.getInstance();
+            mPricesDbAdapter = PricesDbAdapter.getInstance();
             mCommoditiesDbAdapter = CommoditiesDbAdapter.getInstance();
         } else {
             mSplitsDbAdapter = new SplitsDbAdapter(db);
             mTransactionsDbAdapter = new TransactionsDbAdapter(db, mSplitsDbAdapter);
             mAccountsDbAdapter = new AccountsDbAdapter(db, mTransactionsDbAdapter);
             mScheduledActionDbAdapter = new ScheduledActionDbAdapter(db);
-            mPricesDbAdpater = new PricesDbAdapter(db);
+            mPricesDbAdapter = new PricesDbAdapter(db);
             mCommoditiesDbAdapter = new CommoditiesDbAdapter(db);
         }
     }
@@ -121,10 +119,8 @@ public Exporter(ExportParams params, SQLiteDatabase db) {
      * @return String containing the file name
      */
     public static String buildExportFilename(ExportFormat format) {
-        String filename = EXPORT_FILENAME_DATE_FORMAT.format(
-                new Date(System.currentTimeMillis()))
+        return EXPORT_FILENAME_DATE_FORMAT.format(new Date(System.currentTimeMillis()))
                 + "_gnucash_export" + format.getExtension();
-        return filename;
     }
 
     /**
@@ -149,60 +145,19 @@ public static long getExportTime(String filename){
     }
 
     /**
-     * Builds a file (creating folders where necessary) for saving the exported data
-     * @param format Export format which determines the file extension
-     * @return File for export
-     * @see #EXPORT_FOLDER_PATH
+     * Generates the export output
+     * @throws ExporterException if an error occurs during export
      */
-    public static File createExportFile(ExportFormat format){
-        new File(EXPORT_FOLDER_PATH).mkdirs();
-        return new File(EXPORT_FOLDER_PATH + buildExportFilename(format));
-    }
+    public abstract List<String> generateExport() throws ExporterException;
 
     /**
-     * Builds a file for backups of the database (in XML) format.
-     * Backups are usually zipped and have extension ".zip"
-     * @return File for saving backups
-     * @see #BACKUP_FOLDER_PATH
+     * Returns the MIME type for this exporter.
+     * @return MIME type as string
      */
-    public static File buildBackupFile(){
-        new File(BACKUP_FOLDER_PATH).mkdirs();
-        return new File(BACKUP_FOLDER_PATH + buildExportFilename(ExportFormat.XML) + ".zip");
+    public String getExportMimeType(){
+        return "text/plain";
     }
 
-    /**
-     * Returns the most recent backup file from the backup folder
-     * @return Last modified file from backup folder
-     * @see #BACKUP_FOLDER_PATH
-     */
-    public static File getMostRecentBackupFile(){
-        File backupFolder = new File(BACKUP_FOLDER_PATH);
-        if (!backupFolder.exists())
-            return null;
-
-        File[] files = backupFolder.listFiles(new FileFilter() {
-            public boolean accept(File file) {
-                return file.isFile();
-            }
-        });
-        long lastMod = Long.MIN_VALUE;
-        File backupFile = null;
-        for (File file : files) {
-            if (file.lastModified() > lastMod) {
-                backupFile = file;
-                lastMod = file.lastModified();
-            }
-        }
-        return backupFile;
-    }
-
-    /**
-     * Generates the export output
-     * @param writer A Writer to export result to
-     * @throws ExporterException if an error occurs during export
-     */
-    public abstract void generateExport(Writer writer) throws ExporterException;
-
     public static class ExporterException extends RuntimeException{
 
         public ExporterException(ExportParams params){
diff --git a/app/src/main/java/org/gnucash/android/export/ofx/OfxExporter.java b/app/src/main/java/org/gnucash/android/export/ofx/OfxExporter.java
index ab915e40..b116f34f 100644
--- a/app/src/main/java/org/gnucash/android/export/ofx/OfxExporter.java
+++ b/app/src/main/java/org/gnucash/android/export/ofx/OfxExporter.java
@@ -34,10 +34,15 @@
 import org.w3c.dom.Node;
 import org.w3c.dom.ProcessingInstruction;
 
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStreamWriter;
 import java.io.StringWriter;
 import java.io.Writer;
 import java.sql.Timestamp;
+import java.util.ArrayList;
 import java.util.List;
 
 import javax.xml.parsers.DocumentBuilder;
@@ -107,7 +112,8 @@ private void generateOfx(Document doc, Element parent){
 		}
 	}
 
-    public String generateExport() throws ExporterException {
+    // FIXME: Move code to generateExport()
+    private String generateOfxExport() throws ExporterException {
         mAccountsList = mAccountsDbAdapter.getExportableAccounts(mParameters.getExportStartTime());
 
         DocumentBuilderFactory docFactory = DocumentBuilderFactory
@@ -141,25 +147,36 @@ public String generateExport() throws ExporterException {
             return stringWriter.toString();
         } else {
             Node ofxNode = document.getElementsByTagName("OFX").item(0);
-
             write(ofxNode, stringWriter, true);
-
-            StringBuffer stringBuffer = new StringBuffer(OfxHelper.OFX_SGML_HEADER);
-            stringBuffer.append('\n');
-            stringBuffer.append(stringWriter.toString());
             PreferenceManager.getDefaultSharedPreferences(mContext).edit().putString(Exporter.PREF_LAST_EXPORT_TIME, timeStamp).apply();
-            return stringBuffer.toString();
+            return OfxHelper.OFX_SGML_HEADER + '\n' + stringWriter.toString();
         }
     }
 
     @Override
-    public void generateExport(Writer writer) throws ExporterException {
+    public List<String> generateExport() throws ExporterException {
+        BufferedWriter writer = null;
+
         try {
-            writer.write(generateExport());
-        }
-        catch (IOException e) {
+            File file = new File(mParameters.getInternalExportPath());
+            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"));
+            writer.write(generateOfxExport());
+        } catch (IOException e) {
             throw new ExporterException(mParameters, e);
+        } finally {
+            if (writer != null) {
+                try {
+                    writer.close();
+                } catch (IOException e) {
+                    throw new ExporterException(mParameters, e);
+                }
+            }
         }
+
+        List<String> exportedFiles = new ArrayList<>();
+        exportedFiles.add(mParameters.getInternalExportPath());
+
+        return exportedFiles;
     }
 
     /**
@@ -188,4 +205,12 @@ private void write(Node node, Writer outputWriter, boolean omitXmlDeclaration){
             Crashlytics.logException(tfException);
         }
     }
+
+    /**
+     * Returns the MIME type for this exporter.
+     * @return MIME type as string
+     */
+    public String getExportMimeType(){
+        return "text/xml";
+    }
 }
diff --git a/app/src/main/java/org/gnucash/android/export/qif/QifExporter.java b/app/src/main/java/org/gnucash/android/export/qif/QifExporter.java
index 95b7485c..1f3eb6aa 100644
--- a/app/src/main/java/org/gnucash/android/export/qif/QifExporter.java
+++ b/app/src/main/java/org/gnucash/android/export/qif/QifExporter.java
@@ -21,19 +21,18 @@
 import android.preference.PreferenceManager;
 
 import org.gnucash.android.db.AccountsDbAdapter;
-import org.gnucash.android.db.DatabaseSchema;
 import org.gnucash.android.db.TransactionsDbAdapter;
 import org.gnucash.android.export.ExportParams;
 import org.gnucash.android.export.Exporter;
-import org.gnucash.android.model.Transaction;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
-import java.io.Writer;
+import java.io.OutputStreamWriter;
 import java.math.BigDecimal;
 import java.sql.Timestamp;
 import java.util.ArrayList;
@@ -57,7 +56,7 @@ public QifExporter(ExportParams params){
     }
 
     @Override
-    public void generateExport(Writer writer) throws ExporterException {
+    public List<String> generateExport() throws ExporterException {
         final String newLine = "\n";
         TransactionsDbAdapter transactionsDbAdapter = mTransactionsDbAdapter;
         try {
@@ -95,6 +94,10 @@ public void generateExport(Writer writer) throws ExporterException {
                     // trans_uid ASC  : put splits from the same transaction together
                    "acct1_currency ASC, trans_time ASC, trans_uid ASC"
                     );
+
+            File file = new File(mParameters.getInternalExportPath());
+            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"));
+
             try {
                 String currentCurrencyCode = "";
                 String currentAccountUID = "";
@@ -202,22 +205,23 @@ public void generateExport(Writer writer) throws ExporterException {
                     // end last transaction
                     writer.append(QifHelper.ENTRY_TERMINATOR).append(newLine);
                 }
-            }
-            finally {
+                writer.flush();
+            } finally {
                 cursor.close();
+                writer.close();
             }
+
             ContentValues contentValues = new ContentValues();
             contentValues.put(TransactionEntry.COLUMN_EXPORTED, 1);
             transactionsDbAdapter.updateTransaction(contentValues, null, null);
-        }
-        catch (IOException e)
-        {
+
+            /// export successful
+            String timeStamp = new Timestamp(System.currentTimeMillis()).toString();
+            PreferenceManager.getDefaultSharedPreferences(mContext).edit().putString(Exporter.PREF_LAST_EXPORT_TIME, timeStamp).apply();
+            return splitQIF(file);
+        } catch (IOException e) {
             throw new ExporterException(mParameters, e);
         }
-
-        /// export successful
-        String timeStamp = new Timestamp(System.currentTimeMillis()).toString();
-        PreferenceManager.getDefaultSharedPreferences(mContext).edit().putString(Exporter.PREF_LAST_EXPORT_TIME, timeStamp).apply();
     }
 
     /**
@@ -227,16 +231,12 @@ public void generateExport(Writer writer) throws ExporterException {
      * @return a list of paths of the newly created Qif files.
      * @throws IOException if something went wrong while splitting the file.
      */
-    public static List<String> splitQIF(File file) throws IOException {
-        return splitQIF(file, file);
-    }
-
-    public static List<String> splitQIF(File src, File dst) throws IOException {
+    public List<String> splitQIF(File file) throws IOException {
         // split only at the last dot
-        String[] pathParts = dst.getPath().split("(?=\\.[^\\.]+$)");
+        String[] pathParts = file.getPath().split("(?=\\.[^\\.]+$)");
         ArrayList<String> splitFiles = new ArrayList<>();
         String line;
-        BufferedReader in = new BufferedReader(new FileReader(src));
+        BufferedReader in = new BufferedReader(new FileReader(file));
         BufferedWriter out = null;
         try {
             while ((line = in.readLine()) != null) {
@@ -250,7 +250,7 @@ public void generateExport(Writer writer) throws ExporterException {
                     out = new BufferedWriter(new FileWriter(newFileName));
                 } else {
                     if (out == null) {
-                        throw new IllegalArgumentException(src.getPath() + " format is not correct");
+                        throw new IllegalArgumentException(file.getPath() + " format is not correct");
                     }
                     out.append(line).append('\n');
                 }
@@ -263,4 +263,12 @@ public void generateExport(Writer writer) throws ExporterException {
         }
         return splitFiles;
     }
+
+    /**
+     * Returns the mime type for this Exporter.
+     * @return MIME type as string
+     */
+    public String getExportMimeType(){
+        return "text/plain";
+    }
 }
diff --git a/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java b/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
index 6d8179eb..b148e5a6 100644
--- a/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
+++ b/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
@@ -41,10 +41,10 @@
 import org.xmlpull.v1.XmlSerializer;
 
 import java.io.BufferedOutputStream;
+import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
-import java.io.Writer;
 import java.math.BigDecimal;
 import java.sql.Timestamp;
 import java.util.ArrayList;
@@ -53,7 +53,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
-import java.util.UUID;
 import java.util.zip.GZIPOutputStream;
 
 import static org.gnucash.android.db.DatabaseSchema.ScheduledActionEntry;
@@ -426,7 +425,7 @@ private void exportTransactions(XmlSerializer xmlSerializer, boolean exportTempl
             // account guid
             xmlSerializer.startTag(null, GncXmlHelper.TAG_SPLIT_ACCOUNT);
             xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_TYPE, GncXmlHelper.ATTR_VALUE_GUID);
-            String splitAccountUID = null;
+            String splitAccountUID;
             if (exportTemplates){
                 //get the UID of the template account
                  splitAccountUID = mTransactionToTemplateAccountMap.get(curTrxUID).getUID();
@@ -636,7 +635,7 @@ private void exportCommodity(XmlSerializer xmlSerializer, List<Currency> currenc
     private void exportPrices(XmlSerializer xmlSerializer) throws IOException {
         xmlSerializer.startTag(null, GncXmlHelper.TAG_PRICEDB);
         xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_VERSION, "1");
-        Cursor cursor = mPricesDbAdpater.fetchAllRecords();
+        Cursor cursor = mPricesDbAdapter.fetchAllRecords();
         try {
             while(cursor.moveToNext()) {
                 xmlSerializer.startTag(null, GncXmlHelper.TAG_PRICE);
@@ -650,7 +649,7 @@ private void exportPrices(XmlSerializer xmlSerializer) throws IOException {
                 xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);
                 xmlSerializer.text("ISO4217");
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);
-                xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_ID);;
+                xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_ID);
                 xmlSerializer.text(mCommoditiesDbAdapter.getCurrencyCode(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.PriceEntry.COLUMN_COMMODITY_UID))));
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_ID);
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_PRICE_COMMODITY);
@@ -659,7 +658,7 @@ private void exportPrices(XmlSerializer xmlSerializer) throws IOException {
                 xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);
                 xmlSerializer.text("ISO4217");
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);
-                xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_ID);;
+                xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_ID);
                 xmlSerializer.text(mCommoditiesDbAdapter.getCurrencyCode(cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.PriceEntry.COLUMN_CURRENCY_UID))));
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_ID);
                 xmlSerializer.endTag(null, GncXmlHelper.TAG_PRICE_CURRENCY);
@@ -695,16 +694,24 @@ private void exportPrices(XmlSerializer xmlSerializer) throws IOException {
     }
 
     @Override
-    public void generateExport(Writer writer) throws ExporterException{
+    public List<String> generateExport() throws ExporterException {
+        OutputStreamWriter writer = null;
+
         try {
-            String[] namespaces = new String[] {"gnc", "act", "book", "cd", "cmdty", "price", "slot",
+            String[] namespaces = new String[]{"gnc", "act", "book", "cd", "cmdty", "price", "slot",
                     "split", "trn", "ts", "sx", "recurrence"};
+            new File(BACKUP_FOLDER_PATH).mkdirs();
+            FileOutputStream fileOutputStream = new FileOutputStream(getBackupFilePath());
+            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
+            GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bufferedOutputStream);
+            writer = new OutputStreamWriter(gzipOutputStream);
+
             XmlSerializer xmlSerializer = XmlPullParserFactory.newInstance().newSerializer();
             xmlSerializer.setOutput(writer);
             xmlSerializer.startDocument("utf-8", true);
             // root tag
             xmlSerializer.startTag(null, GncXmlHelper.TAG_ROOT);
-            for(String ns : namespaces) {
+            for (String ns : namespaces) {
                 xmlSerializer.attribute(null, "xmlns:" + ns, "http://www.gnucash.org/XML/" + ns);
             }
             // book count
@@ -722,7 +729,7 @@ public void generateExport(Writer writer) throws ExporterException{
             xmlSerializer.endTag(null, GncXmlHelper.TAG_BOOK_ID);
             //commodity count
             List<Currency> currencies = mAccountsDbAdapter.getCurrenciesInUse();
-            for (int i = 0; i< currencies.size();i++) {
+            for (int i = 0; i < currencies.size(); i++) {
                 if (currencies.get(i).getCurrencyCode().equals("XXX")) {
                     currencies.remove(i);
                 }
@@ -742,7 +749,7 @@ public void generateExport(Writer writer) throws ExporterException{
             xmlSerializer.text(mTransactionsDbAdapter.getRecordsCount() + "");
             xmlSerializer.endTag(null, GncXmlHelper.TAG_COUNT_DATA);
             //price count
-            long priceCount = mPricesDbAdpater.getRecordsCount();
+            long priceCount = mPricesDbAdapter.getRecordsCount();
             if (priceCount > 0) {
                 xmlSerializer.startTag(null, GncXmlHelper.TAG_COUNT_DATA);
                 xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_CD_TYPE, "price");
@@ -775,8 +782,31 @@ public void generateExport(Writer writer) throws ExporterException{
         } catch (Exception e) {
             Crashlytics.logException(e);
             throw new ExporterException(mParameters, e);
+        } finally {
+            if (writer != null) {
+                try {
+                    writer.close();
+                } catch (IOException e) {
+                    throw new ExporterException(mParameters, e);
+                }
+            }
         }
+
+        List<String> exportedFiles = new ArrayList<>();
+        // FIXME: this looks weird
+        exportedFiles.add(getBackupFilePath());
+
+        return exportedFiles;
     }
+
+    /**
+     * Returns the MIME type for this exporter.
+     * @return MIME type as string
+     */
+    public String getExportMimeType(){
+        return "text/xml";
+    }
+
     /**
      * Creates a backup of current database contents to the default backup location
      * @return {@code true} if backup was successful, {@code false} otherwise
@@ -784,17 +814,22 @@ public void generateExport(Writer writer) throws ExporterException{
     public static boolean createBackup(){
         ExportParams params = new ExportParams(ExportFormat.XML);
         try {
-            FileOutputStream fileOutputStream = new FileOutputStream(Exporter.buildBackupFile());
-            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
-            GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bufferedOutputStream);
-            OutputStreamWriter outputStreamWriter = new OutputStreamWriter(gzipOutputStream);
-            new GncXmlExporter(params).generateExport(outputStreamWriter);
-            outputStreamWriter.close();
+            new GncXmlExporter(params).generateExport();
             return true;
-        } catch (IOException e) {
+        } catch (ExporterException e) {
             Crashlytics.logException(e);
             Log.e("GncXmlExporter", "Error creating backup", e);
             return false;
         }
     }
+
+    /**
+     * Returns the full path of a file to make database backup.
+     * Backups are done in XML format and are zipped (with ".zip" extension).
+     * @return the file path for backups of the database.
+     * @see #BACKUP_FOLDER_PATH
+     */
+    private static String getBackupFilePath(){
+        return BACKUP_FOLDER_PATH + buildExportFilename(ExportFormat.XML) + ".zip";
+    }
 }
