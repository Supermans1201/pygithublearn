From 198e6a91533f477578ae20085419c176fe510903 Mon Sep 17 00:00:00 2001
From: Ngewi Fet <ngewif@gmail.com>
Date: Sat, 11 Apr 2015 14:30:27 +0200
Subject: [PATCH 1/3] Implemented editing of schedule of a scheduled
 transaction

Requires generating the recurrence rule for the RecurrencePickerDialog
Updated repeat string of recurrence events to be more descriptive
---
 .../android/db/ScheduledActionDbAdapter.java       |  2 +-
 .../gnucash/android/db/TransactionsDbAdapter.java  |  5 +-
 .../java/org/gnucash/android/model/PeriodType.java | 63 ++++++++++++----------
 .../org/gnucash/android/model/ScheduledAction.java | 53 +++++++++++++-----
 .../java/org/gnucash/android/ui/UxArgument.java    |  5 ++
 .../ScheduledTransactionsListFragment.java         | 36 +++----------
 .../ui/transaction/TransactionFormFragment.java    |  8 +--
 .../ui/transaction/TransactionsActivity.java       |  2 +
 8 files changed, 98 insertions(+), 76 deletions(-)

diff --git a/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java b/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
index 876b6033..d5c427cf 100644
--- a/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
@@ -157,7 +157,7 @@ private ScheduledAction buildScheduledEventInstance(final Cursor cursor){
      * @param uid GUID of event
      * @return ScheduledEvent object instance
      */
-    public ScheduledAction getScheduledEvent(String uid){
+    public ScheduledAction getScheduledAction(String uid){
         Cursor cursor = fetchRecord(getID(uid));
 
         ScheduledAction scheduledAction = null;
diff --git a/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java b/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
index 66bf8aef..9981f591 100644
--- a/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
@@ -271,9 +271,10 @@ public Cursor fetchAllScheduledTransactions(){
                 + TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_UID + " = "
                 + ScheduledActionEntry.TABLE_NAME + "." + ScheduledActionEntry.COLUMN_ACTION_UID);
 
-        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + ".*"};
+        String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + ".*",
+                ScheduledActionEntry.TABLE_NAME+"."+ScheduledActionEntry.COLUMN_UID};
         String sortOrder = TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_DESCRIPTION + " ASC";
-        queryBuilder.setDistinct(true);
+//        queryBuilder.setDistinct(true);
 
         return queryBuilder.query(mDb, projectionIn, null, null, null, null, sortOrder);
     }
diff --git a/app/src/main/java/org/gnucash/android/model/PeriodType.java b/app/src/main/java/org/gnucash/android/model/PeriodType.java
index 21435024..345de55d 100644
--- a/app/src/main/java/org/gnucash/android/model/PeriodType.java
+++ b/app/src/main/java/org/gnucash/android/model/PeriodType.java
@@ -21,6 +21,10 @@
 import org.gnucash.android.R;
 import org.gnucash.android.app.GnuCashApplication;
 
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+
 /**
 * Represents a type of period which can be associated with a recurring event
  * @author Ngewi Fet <ngewif@gmail.com>
@@ -55,32 +59,17 @@ public int getMultiplier(){
      * @return Frequency description
      */
     public String getFrequencyDescription() {
-        if (mMultiplier > 1){
-            switch (this) {
-                case DAY:
-                    return "Every " + mMultiplier + " days";
-                case WEEK:
-                    return "Every " + mMultiplier + " weeks";
-                case MONTH:
-                    return "Every " + mMultiplier + " months";
-                case YEAR:
-                    return "Every " + mMultiplier + " years";
-                default:
-                    return "Every " + mMultiplier + " days";
-            }
-        } else {
-            switch (this) {
-                case DAY:
-                    return "Daily";
-                case WEEK:
-                    return "Weekly";
-                case MONTH:
-                    return "Monthly";
-                case YEAR:
-                    return "Yearly";
-                default:
-                    return "Daily";
-            }
+        switch (this) {
+            case DAY:
+                return "DAILY";
+            case WEEK:
+                return "WEEKLY";
+            case MONTH:
+                return "MONTHLY";
+            case YEAR:
+                return "YEARLY";
+            default:
+                return "";
         }
     }
 
@@ -88,7 +77,7 @@ public String getFrequencyDescription() {
      * Returns a localized string describing this period type's frequency.
      * @return String describing period type
      */
-    public String getLocalizedFrequencyDescription(){
+    public String getFrequencyRepeatString(){
         Resources res = GnuCashApplication.getAppContext().getResources();
 
         switch (this) {
@@ -101,8 +90,26 @@ public String getLocalizedFrequencyDescription(){
             case YEAR:
                 return res.getQuantityString(R.plurals.label_every_x_years, mMultiplier);
             default:
-                return res.getQuantityString(R.plurals.label_every_x_days, mMultiplier);
+                return "";
         }
     }
 
+    public String getByParts(long startTime){
+        String partString = "";
+        switch (this){
+            case DAY:
+                break;
+            case WEEK:
+                String dayOfWeek = new SimpleDateFormat("E", Locale.US).format(new Date(startTime));
+                //our parser only supports two-letter day names
+                partString = "BYDAY=" + dayOfWeek.substring(0, dayOfWeek.length()-1).toUpperCase();
+            case MONTH:
+                break;
+            case YEAR:
+                break;
+        }
+        return partString;
+    }
+
+
 }
diff --git a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
index f76674d2..30c3fc19 100644
--- a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
+++ b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
@@ -16,10 +16,15 @@
 package org.gnucash.android.model;
 
 import org.gnucash.android.ui.util.RecurrenceParser;
+import org.joda.time.format.DateTimeFormat;
+import org.joda.time.format.DateTimeFormatter;
 
+import java.io.IOException;
+import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
+import java.util.TimeZone;
 
 /**
 * Represents a scheduled event which is stored in the database and run at regular mPeriod
@@ -257,42 +262,62 @@ public void setExecutionCount(int executionCount){
      * @return String description of repeat schedule
      */
     public String getRepeatString(){
-        String dayOfWeek = new SimpleDateFormat("E", Locale.US).format(new Date(mStartDate));
+        String dayOfWeek = new SimpleDateFormat("EE", Locale.US).format(new Date(mStartDate));
         PeriodType periodType = getPeriodType();
-        StringBuilder ruleBuilder = new StringBuilder(periodType.getLocalizedFrequencyDescription());
-        ruleBuilder.append(" on " + dayOfWeek);
+        StringBuilder ruleBuilder = new StringBuilder(periodType.getFrequencyRepeatString());
+        ruleBuilder.append(" on ").append(dayOfWeek);
         ruleBuilder.append(";");
         if (mEndDate > 0){
-            ruleBuilder.append(" until " + new SimpleDateFormat("M/d", Locale.US).format(new Date(mEndDate)) + ";");
+            ruleBuilder.append(" until ")
+                    .append(SimpleDateFormat.getDateInstance(DateFormat.SHORT).format(new Date(mEndDate)))
+                    .append(";");
         } else if (mTotalFrequency > 0){
-            ruleBuilder.append(" for " + mTotalFrequency + " times;");
+            ruleBuilder.append(" for ").append(mTotalFrequency).append(" times;");
         }
         return ruleBuilder.toString();
     }
 
     /**
      * Creates an RFC 2445 string which describes this recurring event
+     * <p>See http://recurrance.sourceforge.net/</p>
      * @return String describing event
      */
     public String getRuleString(){
-        String dayOfWeek = new SimpleDateFormat("EE", Locale.US).format(new Date(mStartDate));
+        String separator = ";";
         PeriodType periodType = getPeriodType();
-        StringBuilder ruleBuilder = new StringBuilder(periodType.getFrequencyDescription());
-        ruleBuilder.append(" on " + dayOfWeek);
-        ruleBuilder.append(";");
+
+        StringBuilder ruleBuilder = new StringBuilder();
+
+//        =======================================================================
+        //This section complies with the formal rules, but the betterpickers library doesn't like/need it
+
+//        SimpleDateFormat startDateFormat = new SimpleDateFormat("'TZID'=zzzz':'yyyyMMdd'T'HHmmss", Locale.US);
+//        ruleBuilder.append("DTSTART;");
+//        ruleBuilder.append(startDateFormat.format(new Date(mStartDate)));
+//            ruleBuilder.append("\n");
+//        ruleBuilder.append("RRULE:");
+//        ========================================================================
+
+        ruleBuilder.append("FREQ=").append(periodType.getFrequencyDescription()).append(separator);
+        ruleBuilder.append("INTERVAL=").append(periodType.getMultiplier()).append(separator);
+        ruleBuilder.append(periodType.getByParts(mStartDate)).append(separator);
+
         if (mEndDate > 0){
-            ruleBuilder.append(" until " + new SimpleDateFormat("M/d/yyyy", Locale.US).format(new Date(mEndDate)) + ";");
+            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd'T'HHmmss'Z'", Locale.US);
+            df.setTimeZone(TimeZone.getTimeZone("UTC"));
+            ruleBuilder.append("UNTIL=").append(df.format(new Date(mEndDate))).append(separator);
         } else if (mTotalFrequency > 0){
-            ruleBuilder.append(" for " + mTotalFrequency + " times;");
+            ruleBuilder.append("COUNT=").append(mTotalFrequency).append(separator);
         }
+
         return ruleBuilder.toString();
     }
 
     /**
      * Creates a ScheduledAction from a Transaction and a period
-     * @param transaction
-     * @param period
-     * @return
+     * @param transaction Transaction to be scheduled
+     * @param period Period in milliseconds since Epoch
+     * @return Scheduled Action
      */
     public static ScheduledAction parseScheduledAction(Transaction transaction, long period){
         ScheduledAction scheduledAction = new ScheduledAction(ActionType.TRANSACTION);
diff --git a/app/src/main/java/org/gnucash/android/ui/UxArgument.java b/app/src/main/java/org/gnucash/android/ui/UxArgument.java
index 9230bd2c..c2d4ab0f 100644
--- a/app/src/main/java/org/gnucash/android/ui/UxArgument.java
+++ b/app/src/main/java/org/gnucash/android/ui/UxArgument.java
@@ -67,6 +67,11 @@
      */
     public static final String PARENT_ACCOUNT_UID = "parent_account_uid";
 
+    /**
+     * Key for passing the scheduled action UID to the transactions editor
+     */
+    public static final String SCHEDULED_ACTION_UID = "scheduled_action_uid";
+
     //prevent initialization of instances of this class
     private UxArgument(){
         //prevent even the native class from calling the ctor
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java b/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
index fb33929d..f9cbb3fe 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
@@ -193,7 +193,8 @@ public void onListItemClick(ListView l, View v, int position, long id) {
         }
 
         String accountUID = transaction.getSplits().get(0).getAccountUID();
-        openTransactionForEdit(accountUID, mTransactionsDbAdapter.getUID(id));
+        openTransactionForEdit(accountUID, mTransactionsDbAdapter.getUID(id),
+                v.getTag().toString());
     }
 
     /**
@@ -201,11 +202,12 @@ public void onListItemClick(ListView l, View v, int position, long id) {
      * @param accountUID GUID of account to which transaction belongs
      * @param transactionUID GUID of transaction to be edited
      */
-    public void openTransactionForEdit(String accountUID, String transactionUID){
+    public void openTransactionForEdit(String accountUID, String transactionUID, String scheduledActionUid){
         Intent createTransactionIntent = new Intent(getActivity(), TransactionsActivity.class);
         createTransactionIntent.setAction(Intent.ACTION_INSERT_OR_EDIT);
         createTransactionIntent.putExtra(UxArgument.SELECTED_ACCOUNT_UID, accountUID);
         createTransactionIntent.putExtra(UxArgument.SELECTED_TRANSACTION_UID, transactionUID);
+        createTransactionIntent.putExtra(UxArgument.SCHEDULED_ACTION_UID, scheduledActionUid);
         startActivity(createTransactionIntent);
     }
 
@@ -363,26 +365,6 @@ public void run() {
             return view;
         }
 
-        /**
-         * Returns the string representation of the recurrence period of the transaction
-         * @param periodMillis Recurrence period in milliseconds
-         * @return String formatted representation of recurrence period
-         */
-        public String getRecurrenceAsString(long periodMillis){
-            String[] recurrencePeriods = getResources().getStringArray(R.array.key_recurrence_period_millis);
-            String[] recurrenceStrings = getResources().getStringArray(R.array.recurrence_period_strings);
-
-            int index = 0;
-            for (String recurrencePeriod : recurrencePeriods) {
-                long period = Long.parseLong(recurrencePeriod);
-                if (period == periodMillis){
-                    break;
-                }
-                index++;
-            }
-            return recurrenceStrings[index];
-        }
-
         @Override
         public void bindView(View view, Context context, Cursor cursor) {
             super.bindView(view, context, cursor);
@@ -400,12 +382,10 @@ public void bindView(View view, Context context, Cursor cursor) {
             TextView descriptionTextView = (TextView) view.findViewById(R.id.secondary_text);
 
             ScheduledActionDbAdapter scheduledActionDbAdapter = ScheduledActionDbAdapter.getInstance();
-            List<ScheduledAction> events = scheduledActionDbAdapter.getScheduledActionsWithUID(transaction.getUID());
-            StringBuilder repeatStringBuilder = new StringBuilder();
-            for (ScheduledAction event : events) {
-                repeatStringBuilder.append(event.getRepeatString()).append("\n");
-            }
-            descriptionTextView.setText(repeatStringBuilder.toString());
+            String scheduledActionUID = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.ScheduledActionEntry.TABLE_NAME+"."+ DatabaseSchema.ScheduledActionEntry.COLUMN_UID));
+            view.setTag(scheduledActionUID);
+            ScheduledAction scheduledAction = scheduledActionDbAdapter.getScheduledAction(scheduledActionUID);
+            descriptionTextView.setText(scheduledAction.getRepeatString());
 
         }
     }
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
index f15c9cb2..288bcae7 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
@@ -435,9 +435,11 @@ private void initializeViewsWithTransaction(){
         }
 
         mSaveTemplate.setChecked(mTransaction.isTemplate());
-        List<ScheduledAction> scheduledActions = ScheduledActionDbAdapter.getInstance().getScheduledActionsWithUID(mTransaction.getUID());
-        if (!scheduledActions.isEmpty()){
-            mRecurrenceTextView.setText(scheduledActions.get(0).getRuleString());
+        String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);
+        if (scheduledActionUID != null && !scheduledActionUID.isEmpty()) {
+            ScheduledAction scheduledAction = ScheduledActionDbAdapter.getInstance().getScheduledAction(scheduledActionUID);
+            mRecurrenceRule = scheduledAction.getRuleString();
+            mRecurrenceTextView.setText(scheduledAction.getRepeatString());
         }
     }
 
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionsActivity.java b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionsActivity.java
index 56b8e4eb..3d17af06 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionsActivity.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionsActivity.java
@@ -303,11 +303,13 @@ protected void onCreate(Bundle savedInstanceState) {
      */
     private void initializeCreateOrEditTransaction() {
         String transactionUID = getIntent().getStringExtra(UxArgument.SELECTED_TRANSACTION_UID);
+        String scheduledActionUID = getIntent().getStringExtra(UxArgument.SCHEDULED_ACTION_UID);
         Bundle args = new Bundle();
         if (transactionUID != null) {
             mSectionHeaderTransactions.setText(R.string.title_edit_transaction);
             args.putString(UxArgument.SELECTED_TRANSACTION_UID, transactionUID);
             args.putString(UxArgument.SELECTED_ACCOUNT_UID, mAccountUID);
+            args.putString(UxArgument.SCHEDULED_ACTION_UID, scheduledActionUID);
         } else {
             mSectionHeaderTransactions.setText(R.string.title_add_transaction);
             args.putString(UxArgument.SELECTED_ACCOUNT_UID, mAccountUID);

From 31fd5c91d95560bd25849864060ee66c6f119211 Mon Sep 17 00:00:00 2001
From: Ngewi Fet <ngewif@gmail.com>
Date: Sat, 11 Apr 2015 17:37:13 +0200
Subject: [PATCH 2/3] Code documentation and refactoring

---
 .../org/gnucash/android/db/DatabaseHelper.java     | 14 +---
 .../gnucash/android/export/xml/GncXmlExporter.java | 18 +++++-
 .../java/org/gnucash/android/model/PeriodType.java |  6 ++
 .../org/gnucash/android/model/ScheduledAction.java | 74 ++++++++++++++++++++--
 .../main/java/org/gnucash/android/model/Split.java | 56 +++++++++++++++-
 .../org/gnucash/android/model/TransactionType.java |  5 ++
 .../org/gnucash/android/ui/BaseDrawerActivity.java | 27 ++++----
 .../ui/transaction/TransactionFormFragment.java    |  1 -
 8 files changed, 169 insertions(+), 32 deletions(-)

diff --git a/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java b/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
index 843d1e16..cf3bc009 100644
--- a/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
+++ b/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
@@ -50,14 +50,6 @@
 	private static final String DATABASE_NAME = "gnucash_db";
 
 	/**
-	 * Account which the origin account this transaction in double entry mode.
-     * This is no longer used since the introduction of splits
-	 */
-    //TODO: find and eliminate uses. Its services are no longer required
-    @Deprecated
-	public static final String KEY_DOUBLE_ENTRY_ACCOUNT_UID 	= "double_account_uid";
-
-	/**
 	 * SQL statement to create the accounts table in the database
 	 */
 	private static final String ACCOUNTS_TABLE_CREATE = "create table " + AccountEntry.TABLE_NAME + " ("
@@ -175,7 +167,7 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 			if (oldVersion == 1 && newVersion >= 2){
 				Log.i(LOG_TAG, "Adding column for double-entry transactions");
 				String addColumnSql = "ALTER TABLE " + TransactionEntry.TABLE_NAME +
-									" ADD COLUMN " + KEY_DOUBLE_ENTRY_ACCOUNT_UID + " varchar(255)";
+									" ADD COLUMN double_account_uid varchar(255)";
 				
 				//introducing sub accounts
 				Log.i(LOG_TAG, "Adding column for parent accounts");
@@ -398,11 +390,11 @@ private int upgradeDbToVersion7(SQLiteDatabase db) {
                             + SplitEntry.COLUMN_AMOUNT + " < 0 THEN 'DEBIT' ELSE 'CREDIT' END ELSE CASE WHEN "
                             + SplitEntry.COLUMN_AMOUNT + " < 0 THEN 'CREDIT' ELSE 'DEBIT' END END , "
                     + "ABS ( " + TransactionEntry.TABLE_NAME + "_bak.amount ) , "
-                    + TransactionEntry.TABLE_NAME + "_bak." + KEY_DOUBLE_ENTRY_ACCOUNT_UID + " , "
+                    + TransactionEntry.TABLE_NAME + "_bak.double_account_uid , "
                     + TransactionEntry.TABLE_NAME + "_baK." + TransactionEntry.COLUMN_UID
                     + " FROM " + TransactionEntry.TABLE_NAME + "_bak , " + AccountEntry.TABLE_NAME
                     + " ON " + TransactionEntry.TABLE_NAME + "_bak.account_uid = " + AccountEntry.TABLE_NAME + "." + AccountEntry.COLUMN_UID
-                    + " WHERE " + TransactionEntry.TABLE_NAME + "_bak." + KEY_DOUBLE_ENTRY_ACCOUNT_UID + " IS NOT NULL"
+                    + " WHERE " + TransactionEntry.TABLE_NAME + "_bak.double_account_uid IS NOT NULL"
             );
             // drop backup transaction table
             db.execSQL("DROP TABLE " + TransactionEntry.TABLE_NAME + "_bak");
diff --git a/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java b/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
index 55a7dadf..2a55a5bb 100644
--- a/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
+++ b/app/src/main/java/org/gnucash/android/export/xml/GncXmlExporter.java
@@ -55,10 +55,20 @@
  */
 public class GncXmlExporter extends Exporter{
 
+    /**
+     * Construct a new exporter with export parameters
+     * @param params Parameters for the export
+     */
     public GncXmlExporter(ExportParams params) {
         super(params, null);
     }
 
+    /**
+     * Overloaded constructor.
+     * Creates an exporter with an already open database instance.
+     * @param params Parameters for the export
+     * @param db SQLite database
+     */
     public GncXmlExporter(ExportParams params, SQLiteDatabase db) {
         super(params, db);
     }
@@ -168,6 +178,12 @@ private void exportAccounts(XmlSerializer xmlSerializer) throws IOException {
         cursor.close();
     }
 
+    /**
+     * Serializes transactions from the database to XML
+     * @param xmlSerializer XML serializer
+     * @param exportTemplates Flag whether to export templates or normal transactions
+     * @throws IOException if the XML serializer cannot be written to
+     */
     private void exportTransactions(XmlSerializer xmlSerializer, boolean exportTemplates) throws IOException {
         String where = null;
         if (exportTemplates){
@@ -356,7 +372,7 @@ private void exportTransactions(XmlSerializer xmlSerializer, boolean exportTempl
     }
 
     /**
-     * Serializes {@link org.gnucash.android.model.ScheduledAction}s from the database to XML
+     * Serializes {@link ScheduledAction}s from the database to XML
      * @param xmlSerializer XML serializer
      * @throws IOException
      */
diff --git a/app/src/main/java/org/gnucash/android/model/PeriodType.java b/app/src/main/java/org/gnucash/android/model/PeriodType.java
index 345de55d..81039747 100644
--- a/app/src/main/java/org/gnucash/android/model/PeriodType.java
+++ b/app/src/main/java/org/gnucash/android/model/PeriodType.java
@@ -94,6 +94,12 @@ public String getFrequencyRepeatString(){
         }
     }
 
+    /**
+     * Returns the parts of the recurrence rule which describe the day or month on which to run the
+     * scheduled transaction. These parts are the BYxxx
+     * @param startTime Start time of transaction used to determine the start day of execution
+     * @return String describing the BYxxx parts of the recurrence rule
+     */
     public String getByParts(long startTime){
         String partString = "";
         switch (this){
diff --git a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
index 30c3fc19..f84f983a 100644
--- a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
+++ b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
@@ -81,34 +81,66 @@ public ScheduledAction(ActionType actionType){
         mIsEnabled = true; //all actions are enabled by default
     }
 
+    /**
+     * Returns the type of action to be performed by this scheduled action
+     * @return ActionType of the scheduled action
+     */
     public ActionType getActionType() {
         return mActionType;
     }
 
+    /**
+     * Sets the {@link ActionType}
+     * @param actionType Type of action
+     */
     public void setActionType(ActionType actionType) {
         this.mActionType = actionType;
     }
 
+    /**
+     * Returns the GUID of the action covered by this scheduled action
+     * @return GUID of action
+     */
     public String getActionUID() {
         return mActionUID;
     }
 
+    /**
+     * Sets the GUID of the action being scheduled
+     * @param actionUID GUID of the action
+     */
     public void setActionUID(String actionUID) {
         this.mActionUID = actionUID;
     }
 
+    /**
+     * Returns the timestamp of the last execution of this scheduled action
+     * @return Timestamp in milliseconds since Epoch
+     */
     public long getLastRun() {
         return mLastRun;
     }
 
+    /**
+     * Set time of last execution of the scheduled action
+     * @param nextRun Timestamp in milliseconds since Epoch
+     */
     public void setLastRun(long nextRun) {
         this.mLastRun = nextRun;
     }
 
+    /**
+     * Returns the period of this scheduled action
+     * @return Period in milliseconds since Epoch
+     */
     public long getPeriod() {
         return mPeriod;
     }
 
+    /**
+     * Sets the period of the scheduled action
+     * @param period Period in milliseconds since Epoch
+     */
     public void setPeriod(long period) {
         this.mPeriod = period;
     }
@@ -183,14 +215,26 @@ public static PeriodType getPeriodType(long period){
         return periodType;
     }
 
+    /**
+     * Returns the time of first execution of the scheduled action
+     * @return Start time of scheduled action in milliseconds since Epoch
+     */
     public long getStartTime() {
         return mStartDate;
     }
 
+    /**
+     * Sets the time of first execution of the scheduled action
+     * @param startDate Timestamp in milliseconds since Epoch
+     */
     public void setStartTime(long startDate) {
         this.mStartDate = startDate;
     }
 
+    /**
+     * Returns the time of last execution of the scheduled action
+     * @return Timestamp in milliseconds since Epoch
+     */
     public long getEndTime() {
         return mEndDate;
     }
@@ -205,22 +249,47 @@ public long getApproxEndTime(){
         return mStartDate + (mPeriod * mTotalFrequency);
     }
 
+    /**
+     * Sets the end time of the scheduled action
+     * @param endDate Timestamp in milliseconds since Epoch
+     */
     public void setEndTime(long endDate) {
         this.mEndDate = endDate;
     }
 
+    /**
+     * Returns the tag of this scheduled action
+     * <p>The tag saves additional information about the scheduled action,
+     * e.g. such as export parameters for scheduled backups</p>
+     * @return Tag of scheduled action
+     */
     public String getTag() {
         return mTag;
     }
 
+    /**
+     * Sets the tag of the schedules action.
+     * <p>The tag saves additional information about the scheduled action,
+     * e.g. such as export parameters for scheduled backups</p>
+     * @param tag Tag of scheduled action
+     */
     public void setTag(String tag) {
         this.mTag = tag;
     }
 
+    /**
+     * Returns {@code true} if the scheduled action is enabled, {@code false} otherwise
+     * @return {@code true} if the scheduled action is enabled, {@code false} otherwise
+     */
     public boolean isEnabled(){
         return mIsEnabled;
     }
 
+    /**
+     * Toggles the enabled state of the scheduled action
+     * Disabled scheduled actions will not be executed
+     * @param enabled Flag if the scheduled action is enabled or not
+     */
     public void setEnabled(boolean enabled){
         this.mIsEnabled = enabled;
     }
@@ -328,9 +397,6 @@ public static ScheduledAction parseScheduledAction(Transaction transaction, long
 
     @Override
     public String toString() {
-
-        String eventString = mActionType.name() + " - " + getRepeatString();
-
-        return eventString;
+        return mActionType.name() + " - " + getRepeatString();
     }
 }
diff --git a/app/src/main/java/org/gnucash/android/model/Split.java b/app/src/main/java/org/gnucash/android/model/Split.java
index 826d904b..c40e650f 100644
--- a/app/src/main/java/org/gnucash/android/model/Split.java
+++ b/app/src/main/java/org/gnucash/android/model/Split.java
@@ -70,46 +70,94 @@ public Split(Split sourceSplit, boolean generateUID){
         }
     }
 
+    /**
+     * Returns the amount of the split
+     * @return Money amount of the split
+     */
     public Money getAmount() {
         return mAmount;
     }
 
+    /**
+     * Sets the amount of the split
+     * @param amount Money amount of this split
+     */
     public void setAmount(Money amount) {
         this.mAmount = amount;
     }
 
+    /**
+     * Returns transaction GUID to which the split belongs
+     * @return String GUID of the transaction
+     */
     public String getTransactionUID() {
         return mTransactionUID;
     }
 
+    /**
+     * Sets the transaction to which the split belongs
+     * @param transactionUID GUID of transaction
+     */
     public void setTransactionUID(String transactionUID) {
         this.mTransactionUID = transactionUID;
     }
 
+    /**
+     * Returns the account GUID of this split
+     * @return GUID of the account
+     */
     public String getAccountUID() {
         return mAccountUID;
     }
 
+    /**
+     * Sets the GUID of the account of this split
+     * @param accountUID GUID of account
+     */
     public void setAccountUID(String accountUID) {
         this.mAccountUID = accountUID;
     }
 
+    /**
+     * Returns the type of the split
+     * @return {@link TransactionType} of the split
+     */
     public TransactionType getType() {
         return mSplitType;
     }
 
-    public void setType(TransactionType transactionType) {
-        this.mSplitType = transactionType;
+    /**
+     * Sets the type of this split
+     * @param splitType Type of the split
+     */
+    public void setType(TransactionType splitType) {
+        this.mSplitType = splitType;
     }
 
+    /**
+     * Returns the memo of this split
+     * @return String memo of this split
+     */
     public String getMemo() {
         return mMemo;
     }
 
+    /**
+     * Sets this split memo
+     * @param memo String memo of this split
+     */
     public void setMemo(String memo) {
         this.mMemo = memo;
     }
 
+    /**
+     * Creates a split which is a pair of this instance.
+     * A pair split has all the same attributes except that the SplitType is inverted and it belongs
+     * to another account.
+     * @param accountUID GUID of account
+     * @return New split pair of current split
+     * @see TransactionType#invert()
+     */
     public Split createPair(String accountUID){
         Split pair = new Split(mAmount.absolute(), accountUID);
         pair.setType(mSplitType.invert());
@@ -119,6 +167,10 @@ public Split createPair(String accountUID){
         return pair;
     }
 
+    /**
+     * Clones this split and returns an exact copy.
+     * @return New instance of a split which is a copy of the current one
+     */
     protected Split clone() {
         Split split = new Split(mAmount, mAccountUID);
         split.mUID = mUID;
diff --git a/app/src/main/java/org/gnucash/android/model/TransactionType.java b/app/src/main/java/org/gnucash/android/model/TransactionType.java
index 14f4cd97..0306a4c0 100644
--- a/app/src/main/java/org/gnucash/android/model/TransactionType.java
+++ b/app/src/main/java/org/gnucash/android/model/TransactionType.java
@@ -32,6 +32,11 @@
         CREDIT.opposite = DEBIT;
     }
 
+    /**
+     * Inverts the transaction type.
+     * <p>{@link TransactionType#CREDIT} becomes {@link TransactionType#DEBIT} and vice versa</p>
+     * @return Inverted transaction type
+     */
     public TransactionType invert() {
         return opposite;
     }
diff --git a/app/src/main/java/org/gnucash/android/ui/BaseDrawerActivity.java b/app/src/main/java/org/gnucash/android/ui/BaseDrawerActivity.java
index 6d19ab52..01beb2c8 100644
--- a/app/src/main/java/org/gnucash/android/ui/BaseDrawerActivity.java
+++ b/app/src/main/java/org/gnucash/android/ui/BaseDrawerActivity.java
@@ -103,9 +103,10 @@ public void onDrawerOpened(View drawerView) {
     }
 
     private MergeAdapter createNavDrawerMergeAdapter() {
+        //TODO: Localize nav drawer entries when features are finalized
         ArrayList<String> accountNavOptions = new ArrayList<String>();
         accountNavOptions.add("Favorites");
-        accountNavOptions.add("Open...");
+//        accountNavOptions.add("Open...");
         accountNavOptions.add("Reports");
 
         ArrayAdapter<String> accountsNavAdapter = new ArrayAdapter<String>(this,
@@ -140,7 +141,7 @@ private MergeAdapter createNavDrawerMergeAdapter() {
         settingsHeader.setTextColor(titleColorGreen);
 
         ArrayList<String> aboutNavOptions = new ArrayList<String>();
-        aboutNavOptions.add("Backup & Export");
+//        aboutNavOptions.add("Backup & Export");
         aboutNavOptions.add("Settings");
         //TODO: add help view
         ArrayAdapter<String> aboutNavAdapter = new ArrayAdapter<String>(this,
@@ -173,7 +174,9 @@ public boolean onOptionsItemSelected(MenuItem item) {
         return super.onOptionsItemSelected(item);
     }
 
-    /** Swaps fragments in the main content view */
+    /**
+     * Handler for the navigation drawer items
+     * */
     protected void selectItem(int position) {
         switch (position){
             case 1: { //favorite accounts
@@ -184,22 +187,25 @@ protected void selectItem(int position) {
                 startActivity(intent);
             }
                 break;
+/*
 
             case 2: { //Open... files
                 //TODO: open/import GnuCash files
                 Intent pickIntent = new Intent(Intent.ACTION_GET_CONTENT);
-                pickIntent.setType("application/*");
+                pickIntent.setType("application*/
+/*");
                 Intent chooser = Intent.createChooser(pickIntent, "Select GnuCash account file");
 
                 startActivityForResult(chooser, AccountsActivity.REQUEST_PICK_ACCOUNTS_FILE);
             }
                 break;
+*/
 
-            case 3:
+            case 2:
                 startActivity(new Intent(this, PieChartActivity.class));
                 break;
 
-            case 5: { //show scheduled transactions
+            case 4: { //show scheduled transactions
                 Intent intent = new Intent(this, ScheduledActionsActivity.class);
                 intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP|Intent.FLAG_ACTIVITY_SINGLE_TOP);
                 intent.putExtra(ScheduledActionsActivity.EXTRA_DISPLAY_MODE,
@@ -208,17 +214,12 @@ protected void selectItem(int position) {
             }
                 break;
 
-            case 6:{
+            case 5:{
                 AccountsActivity.showExportDialog(this);
             }
                 break;
 
-            case 9: { //Backup and Export
-
-            }
-                break;
-
-            case 10: //Settings activity
+            case 8: //Settings activity
                 startActivity(new Intent(this, SettingsActivity.class));
                 break;
 
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
index 288bcae7..85996d7b 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
@@ -814,7 +814,6 @@ public boolean onOptionsItemSelected(MenuItem item) {
             else if (mAmountEditText.getText().length() == 0) {
                 Toast.makeText(getActivity(), R.string.toast_transanction_amount_required, Toast.LENGTH_SHORT).show();
             } else if (mUseDoubleEntry && mDoubleAccountSpinner.getCount() == 0){
-                //TODO: Localize string
                 Toast.makeText(getActivity(),
                         R.string.toast_disable_double_entry_to_save_transaction,
                         Toast.LENGTH_LONG).show();

From c3b3e0d658f78e08b9f7d241d6021c823ceb6561 Mon Sep 17 00:00:00 2001
From: Ngewi Fet <ngewif@gmail.com>
Date: Mon, 13 Apr 2015 18:17:11 +0200
Subject: [PATCH 3/3] Fixed: editing the schedule of a scheduled transaction
 instead created a new one

Improved the repeat strings for scheduled actions
Added foreign key constraint to transactions table for scheduled action unique ID
Code refactoring
---
 .../org/gnucash/android/db/AccountsDbAdapter.java  | 39 ++-----------
 .../org/gnucash/android/db/DatabaseAdapter.java    | 25 ++++++++
 .../org/gnucash/android/db/DatabaseHelper.java     |  5 +-
 .../org/gnucash/android/db/DatabaseSchema.java     |  2 +-
 .../android/db/ScheduledActionDbAdapter.java       | 42 +++++++++++---
 .../gnucash/android/db/TransactionsDbAdapter.java  | 17 +++---
 .../java/org/gnucash/android/model/PeriodType.java |  8 +--
 .../org/gnucash/android/model/ScheduledAction.java | 16 ++++--
 .../ScheduledTransactionsListFragment.java         |  8 +--
 .../ui/transaction/TransactionFormFragment.java    | 67 +++++++++++++++-------
 .../gnucash/android/ui/util/RecurrenceParser.java  |  5 +-
 11 files changed, 146 insertions(+), 88 deletions(-)

diff --git a/app/src/main/java/org/gnucash/android/db/AccountsDbAdapter.java b/app/src/main/java/org/gnucash/android/db/AccountsDbAdapter.java
index 55c5213f..d25e00eb 100644
--- a/app/src/main/java/org/gnucash/android/db/AccountsDbAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/AccountsDbAdapter.java
@@ -1116,17 +1116,8 @@ public String getFullyQualifiedAccountName(long accountId){
      * @return <code>true</code> if the account is a placeholder account, <code>false</code> otherwise
      */
     public boolean isPlaceholderAccount(String accountUID) {
-        Cursor cursor = mDb.query(AccountEntry.TABLE_NAME,
-                new String[]{AccountEntry.COLUMN_PLACEHOLDER},
-                AccountEntry.COLUMN_UID + " = ?",
-                new String[]{accountUID}, null, null, null);
-
-        try {
-            return cursor.moveToFirst()
-                    && cursor.getInt(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_PLACEHOLDER)) == 1;
-        } finally {
-            cursor.close();
-        }
+        String isPlaceholder = getAttribute(accountUID, AccountEntry.COLUMN_PLACEHOLDER);
+        return Integer.parseInt(isPlaceholder) == 1;
     }
 
     /**
@@ -1135,17 +1126,8 @@ public boolean isPlaceholderAccount(String accountUID) {
      * @return <code>true</code> if the account is hidden, <code>false</code> otherwise
      */
     public boolean isHiddenAccount(String accountUID){
-        Cursor cursor = mDb.query(AccountEntry.TABLE_NAME,
-                new String[]{AccountEntry.COLUMN_HIDDEN},
-                AccountEntry.COLUMN_UID + " = ?",
-                new String[]{accountUID}, null, null, null);
-
-        try {
-            return cursor.moveToFirst()
-                    && cursor.getInt(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_HIDDEN)) == 1;
-        } finally {
-            cursor.close();
-        }
+        String isHidden = getAttribute(accountUID, AccountEntry.COLUMN_HIDDEN);
+        return Integer.parseInt(isHidden) == 1;
     }
 
     /**
@@ -1154,17 +1136,8 @@ public boolean isHiddenAccount(String accountUID){
      * @return <code>true</code> if the account is a favorite account, <code>false</code> otherwise
      */
     public boolean isFavoriteAccount(String accountUID){
-        Cursor cursor = mDb.query(AccountEntry.TABLE_NAME,
-                new String[]{AccountEntry.COLUMN_FAVORITE},
-                AccountEntry.COLUMN_UID + " = ?", new String[]{accountUID},
-                null, null, null);
-
-        try {
-            return cursor.moveToFirst()
-                    && cursor.getInt(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_FAVORITE)) == 1;
-        } finally {
-            cursor.close();
-        }
+        String isFavorite = getAttribute(accountUID, AccountEntry.COLUMN_FAVORITE);
+        return Integer.parseInt(isFavorite) == 1;
     }
 
     /**
diff --git a/app/src/main/java/org/gnucash/android/db/DatabaseAdapter.java b/app/src/main/java/org/gnucash/android/db/DatabaseAdapter.java
index 647a0196..0f976dda 100644
--- a/app/src/main/java/org/gnucash/android/db/DatabaseAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/DatabaseAdapter.java
@@ -400,6 +400,31 @@ public boolean deleteRecord(@NonNull String uid){
     }
 
     /**
+     * Returns an attribute from a specific column in the database for a specific record.
+     * <p>The attribute is returned as a string which can then be converted to another type if
+     * the caller was expecting something other type </p>
+     * @param recordUID GUID of the record
+     * @param columnName Name of the column to be retrieved
+     * @return String value of the column entry
+     * @throws IllegalArgumentException if either the {@code recordUID} or {@code columnName} do not exist in the database
+     */
+    protected String getAttribute(@NonNull String recordUID, @NonNull String columnName){
+        Cursor cursor = mDb.query(mTableName,
+                new String[]{columnName},
+                AccountEntry.COLUMN_UID + " = ?",
+                new String[]{recordUID}, null, null, null);
+
+        try {
+            if (cursor.moveToFirst())
+                return cursor.getString(cursor.getColumnIndexOrThrow(columnName));
+            else
+                throw new IllegalArgumentException("Column or GUID does not exist in the db");
+        } finally {
+            cursor.close();
+        }
+    }
+
+    /**
      * Expose mDb.beginTransaction()
      */
     public void beginTransaction() {
diff --git a/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java b/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
index cf3bc009..37f9cd96 100644
--- a/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
+++ b/app/src/main/java/org/gnucash/android/db/DatabaseHelper.java
@@ -83,7 +83,8 @@
             + TransactionEntry.COLUMN_CURRENCY      + " varchar(255) not null, "
             + TransactionEntry.COLUMN_SCHEDX_ACTION_UID + " varchar(255), "
             + TransactionEntry.COLUMN_CREATED_AT    + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
-            + TransactionEntry.COLUMN_MODIFIED_AT   + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP "
+            + TransactionEntry.COLUMN_MODIFIED_AT   + " TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, "
+            + "FOREIGN KEY (" 	+ TransactionEntry.COLUMN_SCHEDX_ACTION_UID + ") REFERENCES " + ScheduledActionEntry.TABLE_NAME + " (" + ScheduledActionEntry.COLUMN_UID + ") ON DELETE SET NULL "
 			+ ");" + createUpdatedAtTrigger(TransactionEntry.TABLE_NAME);
 
     /**
@@ -107,7 +108,7 @@
     public static final String SCHEDULED_ACTIONS_TABLE_CREATE = "CREATE TABLE " + ScheduledActionEntry.TABLE_NAME + " ("
             + ScheduledActionEntry._ID                   + " integer primary key autoincrement, "
             + ScheduledActionEntry.COLUMN_UID            + " varchar(255) not null UNIQUE, "
-            + ScheduledActionEntry.COLUMN_ACTION_UID + " varchar(255) not null, "
+            + ScheduledActionEntry.COLUMN_ACTION_UID    + " varchar(255) not null, "
             + ScheduledActionEntry.COLUMN_TYPE           + " varchar(255) not null, "
             + ScheduledActionEntry.COLUMN_PERIOD         + " integer not null, "
             + ScheduledActionEntry.COLUMN_LAST_RUN       + " integer default 0, "
diff --git a/app/src/main/java/org/gnucash/android/db/DatabaseSchema.java b/app/src/main/java/org/gnucash/android/db/DatabaseSchema.java
index f658ca6d..9301449a 100644
--- a/app/src/main/java/org/gnucash/android/db/DatabaseSchema.java
+++ b/app/src/main/java/org/gnucash/android/db/DatabaseSchema.java
@@ -79,7 +79,7 @@ private DatabaseSchema(){}
         public static final String COLUMN_TIMESTAMP             = "timestamp";
         public static final String COLUMN_EXPORTED              = "is_exported";
         public static final String COLUMN_TEMPLATE              = "is_template";
-        public static final String COLUMN_SCHEDX_ACTION_UID     = "schedx_action_uid";
+        public static final String COLUMN_SCHEDX_ACTION_UID     = "scheduled_action_uid";
 
         public static final String INDEX_UID                    = "transaction_uid_index";
     }
diff --git a/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java b/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
index d5c427cf..7bb909be 100644
--- a/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/ScheduledActionDbAdapter.java
@@ -72,6 +72,29 @@ public long addScheduledAction(ScheduledAction scheduledAction){
     }
 
     /**
+     * Updates only the recurrence attributes of the scheduled action.
+     * The recurrence attributes are the period, start time, end time and/or total frequency.
+     * All other properties of a scheduled event are only used for interal database tracking and are
+     * not central to the recurrence schedule.
+     * <p><b>The GUID of the scheduled action should already exist in the database</b></p>
+     * @param scheduledAction Scheduled action
+     * @return Database record ID of the edited scheduled action
+     */
+    public long updateRecurrenceAttributes(ScheduledAction scheduledAction){
+        ContentValues contentValues = getContentValues(scheduledAction);
+        contentValues.put(ScheduledActionEntry.COLUMN_PERIOD,    scheduledAction.getPeriod());
+        contentValues.put(ScheduledActionEntry.COLUMN_START_TIME, scheduledAction.getStartTime());
+        contentValues.put(ScheduledActionEntry.COLUMN_END_TIME,  scheduledAction.getEndTime());
+        contentValues.put(ScheduledActionEntry.COLUMN_TAG,       scheduledAction.getTag());
+        contentValues.put(ScheduledActionEntry.COLUMN_TOTAL_FREQUENCY, scheduledAction.getTotalFrequency());
+
+        Log.d(TAG, "Updating scheduled event recurrence attributes");
+        String where = ScheduledActionEntry.COLUMN_UID + "=?";
+        String[] whereArgs = new String[]{scheduledAction.getUID()};
+        return mDb.update(ScheduledActionEntry.TABLE_NAME, contentValues, where, whereArgs);
+    }
+
+    /**
      * Adds a multiple scheduled actions to the database in one transaction.
      * @param scheduledActionList List of ScheduledActions
      * @return Returns the number of rows inserted
@@ -96,16 +119,19 @@ public int bulkAddScheduledActions(List<ScheduledAction> scheduledActionList){
                     + ScheduledActionEntry.COLUMN_EXECUTION_COUNT   + " ) VALUES ( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? )");
             for (ScheduledAction schedxAction:scheduledActionList) {
                 replaceStatement.clearBindings();
-                replaceStatement.bindString(1,  schedxAction.getUID());
-                replaceStatement.bindString(2,  schedxAction.getActionUID());
-                replaceStatement.bindString(3,  schedxAction.getActionType().name());
-                replaceStatement.bindLong(4,    schedxAction.getStartTime());
-                replaceStatement.bindLong(5,    schedxAction.getEndTime());
-                replaceStatement.bindLong(6,    schedxAction.getLastRun());
-                replaceStatement.bindLong(7,    schedxAction.getPeriod());
+                replaceStatement.bindString(1, schedxAction.getUID());
+                replaceStatement.bindString(2, schedxAction.getActionUID());
+                replaceStatement.bindString(3, schedxAction.getActionType().name());
+                replaceStatement.bindLong(4, schedxAction.getStartTime());
+                replaceStatement.bindLong(5, schedxAction.getEndTime());
+                replaceStatement.bindLong(6, schedxAction.getLastRun());
+                replaceStatement.bindLong(7, schedxAction.getPeriod());
                 replaceStatement.bindLong(8,    schedxAction.isEnabled() ? 1 : 0);
                 replaceStatement.bindString(9,  schedxAction.getCreatedTimestamp().toString());
-                replaceStatement.bindString(10, schedxAction.getTag());
+                if (schedxAction.getTag() == null)
+                    replaceStatement.bindNull(10);
+                else
+                    replaceStatement.bindString(10, schedxAction.getTag());
                 replaceStatement.bindString(11, Integer.toString(schedxAction.getTotalFrequency()));
                 replaceStatement.bindString(12, Integer.toString(schedxAction.getExecutionCount()));
 
diff --git a/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java b/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
index 9981f591..f8074679 100644
--- a/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
+++ b/app/src/main/java/org/gnucash/android/db/TransactionsDbAdapter.java
@@ -156,14 +156,17 @@ public long bulkAddTransactions(List<Transaction> transactionList){
             for (Transaction transaction : transactionList) {
                 //Log.d(TAG, "Replacing transaction in db");
                 replaceStatement.clearBindings();
-                replaceStatement.bindString(1,  transaction.getUID());
-                replaceStatement.bindString(2,  transaction.getDescription());
-                replaceStatement.bindString(3,  transaction.getNote());
-                replaceStatement.bindLong(4,    transaction.getTimeMillis());
-                replaceStatement.bindLong(5,    transaction.isExported() ? 1 : 0);
+                replaceStatement.bindString(1, transaction.getUID());
+                replaceStatement.bindString(2, transaction.getDescription());
+                replaceStatement.bindString(3, transaction.getNote());
+                replaceStatement.bindLong(4, transaction.getTimeMillis());
+                replaceStatement.bindLong(5, transaction.isExported() ? 1 : 0);
                 replaceStatement.bindString(6,  transaction.getCurrencyCode());
                 replaceStatement.bindString(7,  transaction.getCreatedTimestamp().toString());
-                replaceStatement.bindString(8,  transaction.getScheduledActionUID());
+                if (transaction.getScheduledActionUID() == null)
+                    replaceStatement.bindNull(8);
+                else
+                    replaceStatement.bindString(8,  transaction.getScheduledActionUID());
                 replaceStatement.bindLong(9,    transaction.isTemplate() ? 1 : 0);
                 replaceStatement.execute();
                 rowInserted ++;
@@ -272,7 +275,7 @@ public Cursor fetchAllScheduledTransactions(){
                 + ScheduledActionEntry.TABLE_NAME + "." + ScheduledActionEntry.COLUMN_ACTION_UID);
 
         String[] projectionIn = new String[]{TransactionEntry.TABLE_NAME + ".*",
-                ScheduledActionEntry.TABLE_NAME+"."+ScheduledActionEntry.COLUMN_UID};
+                ScheduledActionEntry.TABLE_NAME+"."+ScheduledActionEntry.COLUMN_UID + " AS " + "origin_scheduled_action_uid"};
         String sortOrder = TransactionEntry.TABLE_NAME + "." + TransactionEntry.COLUMN_DESCRIPTION + " ASC";
 //        queryBuilder.setDistinct(true);
 
diff --git a/app/src/main/java/org/gnucash/android/model/PeriodType.java b/app/src/main/java/org/gnucash/android/model/PeriodType.java
index 81039747..dc3b2d25 100644
--- a/app/src/main/java/org/gnucash/android/model/PeriodType.java
+++ b/app/src/main/java/org/gnucash/android/model/PeriodType.java
@@ -82,13 +82,13 @@ public String getFrequencyRepeatString(){
 
         switch (this) {
             case DAY:
-                return res.getQuantityString(R.plurals.label_every_x_days, mMultiplier);
+                return res.getQuantityString(R.plurals.label_every_x_days, mMultiplier, mMultiplier);
             case WEEK:
-                return res.getQuantityString(R.plurals.label_every_x_weeks, mMultiplier);
+                return res.getQuantityString(R.plurals.label_every_x_weeks, mMultiplier, mMultiplier);
             case MONTH:
-                return res.getQuantityString(R.plurals.label_every_x_months, mMultiplier);
+                return res.getQuantityString(R.plurals.label_every_x_months, mMultiplier, mMultiplier);
             case YEAR:
-                return res.getQuantityString(R.plurals.label_every_x_years, mMultiplier);
+                return res.getQuantityString(R.plurals.label_every_x_years, mMultiplier, mMultiplier);
             default:
                 return "";
         }
diff --git a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
index f84f983a..e0f5a02f 100644
--- a/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
+++ b/app/src/main/java/org/gnucash/android/model/ScheduledAction.java
@@ -331,17 +331,21 @@ public void setExecutionCount(int executionCount){
      * @return String description of repeat schedule
      */
     public String getRepeatString(){
-        String dayOfWeek = new SimpleDateFormat("EE", Locale.US).format(new Date(mStartDate));
+        String dayOfWeek = new SimpleDateFormat("EEEE", Locale.US).format(new Date(mStartDate));
         PeriodType periodType = getPeriodType();
         StringBuilder ruleBuilder = new StringBuilder(periodType.getFrequencyRepeatString());
-        ruleBuilder.append(" on ").append(dayOfWeek);
-        ruleBuilder.append(";");
+
+        if (periodType == PeriodType.WEEK) {
+            ruleBuilder.append(" on ").append(dayOfWeek);
+        }
+
         if (mEndDate > 0){
+            ruleBuilder.append(", ");
             ruleBuilder.append(" until ")
-                    .append(SimpleDateFormat.getDateInstance(DateFormat.SHORT).format(new Date(mEndDate)))
-                    .append(";");
+                    .append(SimpleDateFormat.getDateInstance(DateFormat.SHORT).format(new Date(mEndDate)));
         } else if (mTotalFrequency > 0){
-            ruleBuilder.append(" for ").append(mTotalFrequency).append(" times;");
+            ruleBuilder.append(", ");
+            ruleBuilder.append(" for ").append(mTotalFrequency).append(" times");
         }
         return ruleBuilder.toString();
     }
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java b/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
index f9cbb3fe..39ef8382 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/ScheduledTransactionsListFragment.java
@@ -110,12 +110,12 @@ public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                         Log.i(TAG, "Cancelling scheduled transaction(s)");
                         String trnUID = mTransactionsDbAdapter.getUID(id);
                         ScheduledActionDbAdapter scheduledActionDbAdapter = GnuCashApplication.getScheduledEventDbAdapter();
-                        List<ScheduledAction> events = scheduledActionDbAdapter.getScheduledActionsWithUID(trnUID);
+                        List<ScheduledAction> actions = scheduledActionDbAdapter.getScheduledActionsWithUID(trnUID);
 
                         if (mTransactionsDbAdapter.deleteRecord(id)){
                             Toast.makeText(getActivity(), R.string.toast_recurring_transaction_deleted, Toast.LENGTH_SHORT).show();
-                            for (ScheduledAction event : events) {
-                                scheduledActionDbAdapter.deleteRecord(event.getUID());
+                            for (ScheduledAction action : actions) {
+                                scheduledActionDbAdapter.deleteRecord(action.getUID());
                             }
                         }
                     }
@@ -382,7 +382,7 @@ public void bindView(View view, Context context, Cursor cursor) {
             TextView descriptionTextView = (TextView) view.findViewById(R.id.secondary_text);
 
             ScheduledActionDbAdapter scheduledActionDbAdapter = ScheduledActionDbAdapter.getInstance();
-            String scheduledActionUID = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.ScheduledActionEntry.TABLE_NAME+"."+ DatabaseSchema.ScheduledActionEntry.COLUMN_UID));
+            String scheduledActionUID = cursor.getString(cursor.getColumnIndexOrThrow("origin_scheduled_action_uid"));
             view.setTag(scheduledActionUID);
             ScheduledAction scheduledAction = scheduledActionDbAdapter.getScheduledAction(scheduledActionUID);
             descriptionTextView.setText(scheduledAction.getRepeatString());
diff --git a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
index 85996d7b..8d2b1342 100644
--- a/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
+++ b/app/src/main/java/org/gnucash/android/ui/transaction/TransactionFormFragment.java
@@ -59,7 +59,6 @@
 import com.doomonafireball.betterpickers.recurrencepicker.RecurrencePickerDialog;
 
 import org.gnucash.android.R;
-import org.gnucash.android.app.GnuCashApplication;
 import org.gnucash.android.db.AccountsDbAdapter;
 import org.gnucash.android.db.DatabaseSchema;
 import org.gnucash.android.db.ScheduledActionDbAdapter;
@@ -191,7 +190,7 @@
     /**
      * Checkbox indicating if this transaction should be saved as a template or not
      */
-    private CheckBox mSaveTemplate;
+    private CheckBox mSaveTemplateCheckbox;
 
     /**
      * Flag to note if double entry accounting is in use or not
@@ -221,6 +220,8 @@
 
     private List<Split> mSplitsList = new ArrayList<Split>();
 
+    private boolean mEditMode = false;
+
     /**
 	 * Create the view and retrieve references to the UI elements
 	 */
@@ -239,7 +240,7 @@ public View onCreateView(LayoutInflater inflater, ViewGroup container,
 		mDoubleAccountSpinner   = (Spinner) v.findViewById(R.id.input_double_entry_accounts_spinner);
         mOpenSplitsButton       = (Button) v.findViewById(R.id.btn_open_splits);
         mRecurrenceTextView     = (TextView) v.findViewById(R.id.input_recurrence);
-        mSaveTemplate           = (CheckBox) v.findViewById(R.id.checkbox_save_template);
+        mSaveTemplateCheckbox = (CheckBox) v.findViewById(R.id.checkbox_save_template);
         return v;
 	}
 
@@ -300,6 +301,7 @@ public void onNothingSelected(AdapterView<?> adapterView) {
             initTransactionNameAutocomplete();
         } else {
 			initializeViewsWithTransaction();
+            mEditMode = true;
 		}
 
 
@@ -434,7 +436,7 @@ private void initializeViewsWithTransaction(){
             enableControls(false);
         }
 
-        mSaveTemplate.setChecked(mTransaction.isTemplate());
+        mSaveTemplateCheckbox.setChecked(mTransaction.isTemplate());
         String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);
         if (scheduledActionUID != null && !scheduledActionUID.isEmpty()) {
             ScheduledAction scheduledAction = ScheduledActionDbAdapter.getInstance().getScheduledAction(scheduledActionUID);
@@ -734,19 +736,24 @@ private void saveNewTransaction() {
 
             // set as not exported.
             mTransaction.setExported(false);
-            //save the normal transaction first
+            mTransaction.setTemplate(mSaveTemplateCheckbox.isChecked());
             mTransactionsDbAdapter.addTransaction(mTransaction);
 
-            if (mSaveTemplate.isChecked()) {
-                Transaction templateTransaction;
-                //creating a new recurring transaction
-                templateTransaction = new Transaction(mTransaction, true);
-                templateTransaction.setTemplate(true);
-                mTransactionsDbAdapter.addTransaction(templateTransaction);
-
-                //inside the if statement because scheduling always creates a template
+            if (mSaveTemplateCheckbox.isChecked()) {
+                Transaction templateTransaction = mTransaction;
+                if (!mEditMode) { //means it was new transaction, so a new template
+                    templateTransaction = new Transaction(mTransaction, true);
+                    templateTransaction.setTemplate(true);
+                    mTransactionsDbAdapter.addTransaction(templateTransaction);
+                }
                 scheduleRecurringTransaction(templateTransaction.getUID());
+            } else {
+                String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);
+                if (scheduledActionUID != null){ //we were editing a schedule and it was turned off
+                    ScheduledActionDbAdapter.getInstance().deleteRecord(scheduledActionUID);
+                }
             }
+
             mAccountsDbAdapter.setTransactionSuccessful();
         }
         finally {
@@ -764,13 +771,27 @@ private void saveNewTransaction() {
      * @see #saveNewTransaction()
      */
     private void scheduleRecurringTransaction(String transactionUID) {
+        ScheduledActionDbAdapter scheduledActionDbAdapter = ScheduledActionDbAdapter.getInstance();
+
         List<ScheduledAction> events = RecurrenceParser.parse(mEventRecurrence,
                 ScheduledAction.ActionType.TRANSACTION);
 
-        if (events.size() == 0) //there are no scheduled events detected
-            return;
+        String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);
+
+        if (scheduledActionUID != null) { //if we are editing an existing schedule
+            if ( events.size() == 1) {
+                ScheduledAction scheduledAction = events.get(0);
+                scheduledAction.setUID(scheduledActionUID);
+                scheduledActionDbAdapter.updateRecurrenceAttributes(scheduledAction);
+                Toast.makeText(getActivity(), "Updated transaction schedule", Toast.LENGTH_SHORT).show();
+                return;
+            } else {
+                //if user changed scheduled action so that more than one new schedule would be saved,
+                // then remove the old one
+                ScheduledActionDbAdapter.getInstance().deleteRecord(scheduledActionUID);
+            }
+        }
 
-        ScheduledActionDbAdapter scheduledActionDbAdapter = GnuCashApplication.getScheduledEventDbAdapter();
         for (ScheduledAction event : events) {
             event.setActionUID(transactionUID);
             event.setLastRun(System.currentTimeMillis());
@@ -778,8 +799,10 @@ private void scheduleRecurringTransaction(String transactionUID) {
 
             Log.i("TransactionFormFragment", event.toString());
         }
-        if (events.size() > 0) //TODO: localize this toast string for all supported locales
-            Toast.makeText(getActivity(), "Scheduled transaction", Toast.LENGTH_SHORT).show();
+        Toast.makeText(getActivity(), "Scheduled transaction", Toast.LENGTH_SHORT).show();
+
+        //TODO: localize this toast string for all supported locales
+
     }
 
 
@@ -937,11 +960,11 @@ public void onRecurrenceSet(String rrule) {
             repeatString = EventRecurrenceFormatter.getRepeatString(getActivity(), getResources(), mEventRecurrence, true);
 
             //when recurrence is set, we will definitely be saving a template
-            mSaveTemplate.setChecked(true);
-            mSaveTemplate.setEnabled(false);
+            mSaveTemplateCheckbox.setChecked(true);
+            mSaveTemplateCheckbox.setEnabled(false);
         } else {
-            mSaveTemplate.setEnabled(true);
-            mSaveTemplate.setChecked(false);
+            mSaveTemplateCheckbox.setEnabled(true);
+            mSaveTemplateCheckbox.setChecked(false);
         }
 
         mRecurrenceTextView.setText(repeatString);
diff --git a/app/src/main/java/org/gnucash/android/ui/util/RecurrenceParser.java b/app/src/main/java/org/gnucash/android/ui/util/RecurrenceParser.java
index fe5b993d..81a03141 100644
--- a/app/src/main/java/org/gnucash/android/ui/util/RecurrenceParser.java
+++ b/app/src/main/java/org/gnucash/android/ui/util/RecurrenceParser.java
@@ -50,8 +50,11 @@
      * @return List of ScheduledEvents
      */
     public static List<ScheduledAction> parse(EventRecurrence eventRecurrence, ScheduledAction.ActionType actionType){
-        long period = 0;
+        long period;
         List<ScheduledAction> scheduledActionList = new ArrayList<ScheduledAction>();
+        if (eventRecurrence == null)
+            return scheduledActionList;
+
         switch(eventRecurrence.freq){
             case EventRecurrence.DAILY: {
                 if (eventRecurrence.interval == 0) //I assume this is a bug from the picker library
